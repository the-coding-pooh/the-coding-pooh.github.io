<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Yen Tzu-Chiao">







<title>On a New Algorithm for Tree Decomposition | the coding pooh&#39;s blog</title>



    <link rel="icon" href="/favico.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/menu.js"></script>
    




    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>







  <!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><style type="text/css">
.spoiler {
  display: inline;
}
p.spoiler {
  display: flex;
}
.spoiler a {
  pointer-events: none;
}
.spoiler-blur, .spoiler-blur > * {
  transition: text-shadow .5s ease;
}
.spoiler .spoiler-blur, .spoiler .spoiler-blur > * {
  color: rgba(0, 0, 0, 0);
  background-color: rgba(0, 0, 0, 0);
  text-shadow: 0 0 10px grey;
  cursor: pointer;
}
.spoiler .spoiler-blur:hover, .spoiler .spoiler-blur:hover > * {
  text-shadow: 0 0 5px grey;
}
.spoiler-box, .spoiler-box > * {
  transition: color .5s ease,
  background-color .5s ease;
}
.spoiler .spoiler-box, .spoiler .spoiler-box > * {
  color: black;
  background-color: black;
  text-shadow: none;
}</style><meta name="generator" content="Hexo 7.3.0"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            <img class="logo-img" src="/logo.jpg" alt="logo_image">
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">Home</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/tag/">Tags</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">Archive</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/categories/gallery/">Gallery</a>
              </li> 
                   
          
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
                
                    <span class="post-tag">
                        <a href="/tags/Algorithm/">
                            Algorithm
                        </a>
                    </span>    
                
                    <span class="post-tag">
                        <a href="/tags/Tree/">
                            Tree
                        </a>
                    </span>    
                
                    <span class="post-tag">
                        <a href="/tags/Decomposition/">
                            Decomposition
                        </a>
                    </span>    
                           
            
        </div>
        <div class="post-title">
            
            
                On a New Algorithm for Tree Decomposition
            
            
        </div>
        <span class="post-date">
            8月 26, 2024
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Written by pooh at 2024&#x2F;08&#x2F;25</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面先講一些廢話，就這大概是我從 2024 的 5 月底開始研究的一個東西，大概實際雛形完整是在 6 月中的時候，原本是想說當作我的資訊專題，但去找了蔡孟宗教授 orz 後跟他談了一下，覺得他講得挺有道理的，就這個內容大概只能當篇 還不錯的 codeforces blog 或比較笨的人寫的<a target="_blank" rel="noopener" href="https://github.com/enkerewpo/OI-Public-Library/tree/master/IOI%E4%B8%AD%E5%9B%BD%E5%9B%BD%E5%AE%B6%E5%80%99%E9%80%89%E9%98%9F%E8%AE%BA%E6%96%87">国家集训队 20XX 论文集</a>這種東西，所以我後來就又去做其他比較有趣一點的東西了。</p>
<p>然後因為前幾天發現天哪暑假要結束了，專題、資讀、免修考、校內賽等等好多東西要練喔，那我就來逃避事實架個 blog 吧，所以我就問餘切我 blog 第一篇要寫啥，他說某些教學文，但我會的而且沒有其他比較好的教學文的就只有樹分塊了QAQ，所以就有了這一篇。</p>
<p>最後是因為這是我第一次寫這種很多內容的文章，所以如果有看不懂的或我寫很爛的都可以來嗆我沒關係，我會盡量改。</p>
<h1 id="樹分塊"><a href="#樹分塊" class="headerlink" title="樹分塊"></a>樹分塊</h1><p>好欸! 那首先先釐清一下我想要幹嘛，就那個時候我在準備資讀的分塊講義，(<del>我以後不知道要怎麼水文章數的時候就會開始搬我自己做的講義過來</del>)，那我當然就去研究了所謂「真‧樹上莫隊」，跟稍微看了一下樹分塊，這個時候就看到了<a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/tree-decompose/">OI wiki</a>，然後就看到他說</p>
<p><img src="/../Images/20240825/OI_wiki_Hoolan.jpg" alt="OI wiki hoolan"></p>
<p>然後我就發現，他根本在唬爛我，明明就是可以做複雜度有保證的，所以我先在這邊講一下那題在幹嘛。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2137">Gty 的妹子树</a></p>
<p>題目大意是 : 給一棵 $n$ 個點的帶點權的定根樹，要求在線支援 $m$ 筆操作</p>
<ol>
<li>給$u, x$ ，將點 $u$ 的權改成 $x$</li>
<li>給$u, x$ ，加一個編號是現在樹的大小 + 1 的點，把他的父節點當 $u$，點權設為 $x$</li>
<li>給$u, x$ ，詢問點 $u$ 的子樹內有幾個點的點權嚴格大於 $x$</li>
</ol>
<p>$n, m \le 3 \times 10^4$</p>
<p>這就是我們目標要做的問題了，哪接著我們一步一步來看看要怎麼沒用快讀快寫成為這一題的最優解，然後去題解區看別人唬爛，然後再用這個樹分塊去嗆人或被嗆。</p>
<h2 id="0-小觀察跟看一下別人在幹嘛"><a href="#0-小觀察跟看一下別人在幹嘛" class="headerlink" title="0. 小觀察跟看一下別人在幹嘛"></a>0. 小觀察跟看一下別人在幹嘛</h2><p>面對這樣的一個分塊演算法，我們很直覺會希望說如果我們能有一種保證塊樹，每塊大小和連通性都很好的分塊法，可是我們先看一下樹上莫隊的那種分塊法(a.k.a. 王室分塊)，他不保證連通性欸，然後我們就跑去翻 <a target="_blank" rel="noopener" href="https://github.com/enkerewpo/OI-Public-Library/blob/master/IOI%E4%B8%AD%E5%9B%BD%E5%9B%BD%E5%AE%B6%E5%80%99%E9%80%89%E9%98%9F%E8%AE%BA%E6%96%87/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F2015%E8%AE%BA%E6%96%87%E9%9B%86.pdf">国家集训队2015论文集</a> 看鄒逍遙那一篇，然後發現他是巨砲，教你深度分塊，保證到根上的經過的數量，但不保證總數，然後你又看到有人做BFS分塊，也是一樣的狀況，甚至還有人直接用 euler tour 亂分。</p>
<p>反正沒有 OIer 做我們想要的，所以我們就自己做吧!  <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="之所以說 OIer 是因為吳邦一老師就有寫[這篇](https://www.sciencedirect.com/science/article/pii/S0166218X12004337)酷東西">1</span></a></sup></p>
<h2 id="1-先定義一下"><a href="#1-先定義一下" class="headerlink" title="1. 先定義一下"></a>1. 先定義一下</h2><p>首先先謝謝 owoovo orz 在定義與證明上的幫助 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="謝謝施竣耀學長 orzorz">2</span></a></sup></p>
<p>我們先定義比Ina弱一點但還蠻好的 $K$ 邊分塊(簡稱好$K$-分塊)。 <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="沒辦法，Ina 太強了">3</span></a></sup></p>
<h3 id="Definition-1-1-好-K-分塊"><a href="#Definition-1-1-好-K-分塊" class="headerlink" title="Definition 1.1 : 好$K$-分塊"></a>Definition 1.1 : 好$K$-分塊</h3><p>當一棵樹的 $E$ (邊集) 的分割 (Partition) $B_1 \dots B_N$，滿足</p>
<ol>
<li>$\forall B_i, B_i \ 是連通的$</li>
<li>$\forall B_i, \vert B_i \vert \in O(K)$</li>
<li>$N \in O(\frac {\vert E \vert} K)$</li>
</ol>
<p>$B_1 \dots B_N$為一組好$K$-分塊</p>
<p>每個塊 $B$ 中有出現的點集為 $V_B$</p>
<p>同時定義定根樹上的好$K$-分塊</p>
<h3 id="Definition-1-2-好-K-分塊-定根樹"><a href="#Definition-1-2-好-K-分塊-定根樹" class="headerlink" title="Definition 1.2 : 好$K$-分塊 (定根樹)"></a>Definition 1.2 : 好$K$-分塊 (定根樹)</h3><p>我們先將這棵定根樹的每個邊定向，方向為深度淺的節點向深度深的節點。<br>當一棵定根樹定向後的 $E$ 的分割 $B_1 \dots B_N$，滿足</p>
<ol>
<li>$\forall B_i, \exists v$ 可以只透過 $B_i$ 內的邊到達所有 $V_{B_i}$ 內的點</li>
<li>$\forall B_i, \vert B_i \vert \in O(K)$</li>
<li>$N \in O(\frac {\vert E \vert} K)$</li>
</ol>
<p>$B_1 \dots B_N$為一組好$K$-分塊</p>
<p>以下我們稱 $B$ 為”一塊”</p>
<h3 id="Lemma-1-1"><a href="#Lemma-1-1" class="headerlink" title="Lemma 1.1 :"></a>Lemma 1.1 :</h3><p>對於一組好$K$-分塊，每一塊是一棵樹<br>proof :<br>我們先證明每一塊中任兩點簡單路徑唯一 :<br>假設存在 $(u,v)$ 之間兩條相異簡單路徑 $R_1, R_2$， 因為$\forall e \in R_1, R_2, e \in E$，所以在原本的圖上 $(u,v)$ 也存在此兩條相異簡單路徑，但原圖是樹，所以矛盾。<br>所以每一塊有任兩點簡單路徑唯一且連通，也就是每一塊都是一棵樹</p>
<h3 id="Definition-1-3-對於一組好-K-分塊-B-1-dots-B-N-的點集-V-B-1-dots-V-B-N-，定義若一個點-v-滿足-exists-i-j-s-t-i-ne-j-land-v-in-V-B-i-land-v-in-V-B-j"><a href="#Definition-1-3-對於一組好-K-分塊-B-1-dots-B-N-的點集-V-B-1-dots-V-B-N-，定義若一個點-v-滿足-exists-i-j-s-t-i-ne-j-land-v-in-V-B-i-land-v-in-V-B-j" class="headerlink" title="Definition 1.3 : 對於一組好$K-$分塊 $B_1 \dots B_N$ 的點集 $V_{B_1} \dots V_{B_N}$，定義若一個點 $v$ 滿足 $\exists (i,j) \ s.t. i \ne j \land (v \in V_{B_i} \land v \in V_{B_j})$"></a>Definition 1.3 : 對於一組好$K-$分塊 $B_1 \dots B_N$ 的點集 $V_{B_1} \dots V_{B_N}$，定義若一個點 $v$ 滿足 $\exists (i,j) \ s.t. i \ne j \land (v \in V_{B_i} \land v \in V_{B_j})$</h3><p>$v$ 是這組好$K$-分塊的一個 cut </p>
<p><strong>注意到一個 cut 可能會同時出現在很多個 $V_B$ 內</strong></p>
<h3 id="Lemma-1-2"><a href="#Lemma-1-2" class="headerlink" title="Lemma 1.2 :"></a>Lemma 1.2 :</h3><p>對於一棵定根樹的好$K$-分塊，每個 cut 都在至少一塊中當根<br>proof :<br>WLOG 只討論一個 cut $u$<br>首先我們知道與與 $u$ 相鄰的點只有一個深度比他淺 (樹的性質)，因此對於 $u$ 只有一條邊 $e$ 定向後是入邊，只有在 $e$ 存在的那一塊 $u$ 可能不是根，根據 cut 的定義他至少存在於至少兩塊，因此他至少會在一塊中當根。</p>
<p>在 $B$ 中當根的 cut 我稱之為 root cut</p>
<p>因此我們知道</p>
<h3 id="Property-1-1"><a href="#Property-1-1" class="headerlink" title="Property 1.1 :"></a>Property 1.1 :</h3><p>$n(cut) \in O(\frac {\vert E \vert} K)$ <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="在此 $n(cut)$ 表示根據該分塊法下 cut 的數量">4</span></a></sup></p>
<p>在此我 claim 說只要我們會做好$K$-分塊，對於可於好的複雜度合併結果的詢問，我們有一個很好可以維護詢問路徑、詢問子樹、點&#x2F;邊改值，加點的甚至某些情況的斷邊刪邊資料結構(?)</p>
<p>同時我 claim 說這個資結搬到水母圖上也可以維護詢問路徑、點 &#x2F; 邊改值、加點的資料結構</p>
<p>痾好欸，打完嘴砲了，開始講演算法。</p>
<h2 id="2-Pooh-受到-Ina-感召的樹分塊演算法-以下簡稱樹分塊"><a href="#2-Pooh-受到-Ina-感召的樹分塊演算法-以下簡稱樹分塊" class="headerlink" title="2. Pooh 受到 Ina 感召的樹分塊演算法 (以下簡稱樹分塊)"></a>2. Pooh 受到 Ina 感召的樹分塊演算法 (以下簡稱樹分塊)</h2><p>痾演算法的本質就是我要分塊，然後維護分塊的東西跟分塊的過程跟蓋圓方樹還有做 Tarjan 縮 BCC 很像，為了實作方便我們先定一個虛根 $\varnothing$ (因為這個符號長得很帥) ，對於一棵定根樹，我們建一條便從 $\varnothing$ 到根，對於不定根樹我們就任意挑一個點當根接到 $\varnothing$ 上<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="下方的pseudocode我改成用0">5</span></a></sup>。</p>
<p>整個樹分塊分為兩部分，我稱之為 decompose<br>跟 build， decompose 是用一次 dfs 決定出一組好$K$-分塊，build 是用一次 dfs 維護好每一塊的內容物與塊之間的關係。</p>
<h3 id="Algorithm-2-1-decompose-定根樹"><a href="#Algorithm-2-1-decompose-定根樹" class="headerlink" title="Algorithm 2.1 decompose (定根樹)"></a>Algorithm 2.1 decompose (定根樹)</h3><blockquote>
<p>輸入 :<br>一棵定根樹 $T(V,E)$ 與 $K$<br>輸出 :<br>給你樹 $T(V,E)$ 的一個$K$-分塊總共有幾塊，每一個非 cut 所屬塊的編號, 每個點是否是 cut 與每一塊的 root cut</p>
</blockquote>
<p>Pseudocode:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SET_BLOCK</span>(v):</span><br><span class="line">BLK_CNT++</span><br><span class="line">WHILE top of DFS_STK != v <span class="keyword">do</span></span><br><span class="line">    BLK_NUM[top of DFS_STK] := BLK_CNT</span><br><span class="line">    POP DFS_STK</span><br><span class="line">ENDWHILE</span><br><span class="line">IS_CUT[v] := <span class="literal">true</span>, ROOT_CUT[BLK_CNT] := v</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="built_in">DFS_DECOMPOSE</span>(v):</span><br><span class="line">UNDETERMINED := <span class="number">0</span></span><br><span class="line">DFS_STK.<span class="built_in">push</span>(v)</span><br><span class="line">FOR each child u of v <span class="keyword">do</span></span><br><span class="line">    UNDETERMINED += <span class="built_in">DFS_DECOMPOSE</span>(u)</span><br><span class="line">    IF UNDETERMINED &gt;= K then </span><br><span class="line">        <span class="built_in">SET_BLOCK</span>(v)</span><br><span class="line">        UNDETERMINED := <span class="number">0</span></span><br><span class="line">    ENDIF</span><br><span class="line">ENDFOR</span><br><span class="line">RETURN UNDETERMINED</span><br><span class="line"></span><br><span class="line">algorithm <span class="built_in">decompose</span>():</span><br><span class="line">FOR v in V <span class="keyword">do</span></span><br><span class="line">    BLK_NUM[v] := <span class="number">0</span>, IS_CUT[v] := <span class="literal">false</span></span><br><span class="line">ENDFOR</span><br><span class="line">BLK_CNT := <span class="number">0</span>, DFS_STK := empty_stack</span><br><span class="line">FOR i = <span class="number">1</span> to <span class="built_in">n</span>(E)/K <span class="keyword">do</span></span><br><span class="line">    ROOT_CUT[i] := <span class="number">0</span></span><br><span class="line">ENDFOR</span><br><span class="line"><span class="built_in">ADD</span> (<span class="number">0</span>, root) to E</span><br><span class="line"><span class="built_in">DFS_DECOMPOSE</span>(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">SET_BLOCK</span>(<span class="number">0</span>)   </span><br><span class="line">RETURN BLK_CNT, BLK_NUM, IS_CUT, ROOT_CUT</span><br></pre></td></tr></table></figure>

<h3 id="Corollary-2-1"><a href="#Corollary-2-1" class="headerlink" title="Corollary 2.1 :"></a>Corollary 2.1 :</h3><p>呼叫 decompose 的時間複雜度為 $O(\vert V \vert + \vert E \vert) &#x3D; O(\vert V \vert)$<br>proof :<br>只有一次 dfs</p>
<h3 id="Lemma-2-1"><a href="#Lemma-2-1" class="headerlink" title="Lemma 2.1 :"></a>Lemma 2.1 :</h3><p>上面的演算法每一塊 $\vert B \vert \le 2K - 1$<br>proof :<br>我先證明 $\forall \vert B \vert \le \max(\text{UNDETERMINE})$，再證明 $\max(\text{UNDETERMINE}) \le 2K - 1$</p>
<p>首先說明每次呼叫 $\text{DFS_DECOMPOSE}$, 最終的 $\text{UNDETERMINE}$ 即為 $\text{DFS_STK}$ 中有幾個元素在 $v$ 上 :</p>
<p>考慮在沒有呼叫 $\text{SET_BLOCK}$ 的狀況下顯然成立，因為 $\text{UNDERTERMINE}$ 即為 $v$ 的子樹大小，而在回傳時 dfs 序比 $v$ 後面的也只有 $v$ 的子孫。<br>接著說明呼叫 $\text{SET_BLOCK}$ 不影響此結論，每次呼叫 $\text{SET_BLOCK}$ 後會將他在 $\text{DFS_STK}$ 上面所有元素移出，並將 $\text{UNDETERMINE}$ 歸零，因此不影響此結論。</p>
<p>所以可以知道每一塊的 $\vert V_B \vert &#x3D;$ 該次呼叫 $\text{SET_BLOCK}$ 時的 $\text{UNDETERMINE} + 1$ (所有且只有 $v$ 與 $\text{DFS_STK}$ 在 $v$ 上面的屬於 $V_B$)，而 $\vert B \vert &#x3D; \vert V_B \vert - 1$ (Lemma 1.1)，所以我有$\forall \vert B \vert \le \max(\text{UNDETERMINE})$。</p>
<p>而我們對於所有 $\text{DFS_DECOMPOSE}$，去證明他的 $\max(\text{UNDETERMINE}) \le 2K$，我們知道每次回傳值$\le K$ (因為最終的$\text{UNDETERMINE} \le K-1$)，而每一次呼叫 $\text{DFS_DECOMPOSE}$ 時最大的$\text{UNDETERMINE} \le K - 1$，所以呼叫完的$\max(\text{UNDETERMINE}) \le 2K - 1$</p>
<p>總和上述兩點可證 $\vert B \vert \le 2K - 1$</p>
<h3 id="Lemma-2-2"><a href="#Lemma-2-2" class="headerlink" title="Lemma 2.2 :"></a>Lemma 2.2 :</h3><p>$\text{BLK_CNT} \le \lfloor \frac {\vert E \vert + 1} K \rfloor + 1$<br>proof :<br>顯然 $\text{BLK_CNT}$ &#x3D; $\text{SET_BLOCK}$ 被呼叫的次數，可以知道在 $\text{DFS_DECOMPOSE}$ 的過程中一定最少要有 $K$ 個點進去 $\text{DFS_STK}$ 才會呼叫一次 $\text{BLK_CNT}$，加上最後呼叫的一次，總共必定少於$\lfloor \frac {\vert E \vert + 1} K \rfloor + 1$，所以有 $\text{BLK_CNT} \le \lfloor \frac {\vert E \vert + 1} K \rfloor + 1$</p>
<h3 id="Lemma-2-3"><a href="#Lemma-2-3" class="headerlink" title="Lemma 2.3 :"></a>Lemma 2.3 :</h3><p>呼叫 $\text{decompose}$ 後分出的每一塊都是連通的<br>proof :<br>每次呼叫 $\text{SET_BLOCK}$ 時分到一塊的一定遞迴要回傳時 $\text{DFS_STK}$ 在他後面的，也就是他的子樹，因此如果他在子樹內沒有呼叫到 $\text{SET_BLOCK}$ 便顯然成立。而當在子樹內有呼叫到 $\text{SET_BLOCK}$ 時被拔除的邊也是完整的一棵子樹，一棵樹去掉一棵子樹後還是連通，因此可以得證。</p>
<p>有趣的是，我們到這一步以後我們就可以發現我們做出的是一個 min-max ratio 3 以內的 CEP tree 欸，好吧可能不是很有趣，因為這個其實大家都會做。</p>
<p>因此根據 Lemma 2.1, Lemma 2.2, Lemma 2.3，我們可以得到 $\text{decompose}$ 的結果滿足</p>
<ol>
<li>$\forall B_i, \exists v$ 可以只透過 $B_i$ 內的邊到達所有 $V_{B_i}$ 內的點 (Lemma 2.3)</li>
<li>$\forall B_i, \vert B_i \vert \in O(K)$ (Lemma 2.1)</li>
<li>$N \in O(\frac {\vert E \vert} K)$ (Lemma 2.2)</li>
</ol>
<p>因此有</p>
<h3 id="Corollary-2-2"><a href="#Corollary-2-2" class="headerlink" title="Corollary 2.2 :"></a>Corollary 2.2 :</h3><p>$\text{decompose}$ 後得到的分塊是一組好$K$-分塊</p>
<p>這時我們觀察到若直接用原圖，則要在塊內 dfs 時可能可能會在星狀圖 (star) 上退化到 $O(K+\vert V \vert)$ (因為要判斷相鄰兩點是否在同一塊，會檢查所有相鄰的點)，因此需要 build 來將原圖拆成每塊獨立的森林<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="同時在星狀圖上，若沒有對邊集 unique，cut tree 極有可能會有 $O(\vert V \vert)$ 條邊，也會造成時間複雜度的問題">6</span></a></sup>。</p>
<p>更明確的說，在這張圖 (Star-5) 上，當要對 $0$ 所屬的那一塊做事時，就會需要遍歷所有的邊，然後就死掉了，因此會需要 build。</p>
<p><img src="/../Images/20240825/Star_5.png" alt="Star_5"></p>
<p>而因為 cut 會出現超過一次，因此我把 root cut 改建虛點，以下稱第 $i$ 塊的虛點編號為 $\text{vir}(i)$</p>
<h3 id="Algorithm-2-2-build"><a href="#Algorithm-2-2-build" class="headerlink" title="Algorithm 2.2 : build"></a>Algorithm 2.2 : build</h3><blockquote>
<p>輸入 : decompose 後的所有輸出<br>輸出 : 一個森林 $\text{BLK_TREE}$ 代表分塊後各塊獨立的結果，$\text{CUT_TREE}$ 代表將每塊縮成一條邊的樹。</p>
</blockquote>
<p>Psuedocode :</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DFS_BUILD</span>(v):</span><br><span class="line"><span class="function">FOR each child u of v <span class="keyword">do</span></span></span><br><span class="line"><span class="function">    <span class="title">DFS_BUILD</span><span class="params">(u)</span></span></span><br><span class="line"><span class="function">    IF BLK_NUM[v] </span>= BLK_NUM[u] <span class="function">then</span></span><br><span class="line"><span class="function">        <span class="title">ADD</span> <span class="params">(v, u)</span> to BLK_TREE</span></span><br><span class="line"><span class="function">    ELSE IF IS_CUT[v] then</span></span><br><span class="line"><span class="function">        <span class="title">ADD</span> <span class="params">(vir(BLK_NUM[u]), u)</span> to BLK_TREE</span></span><br><span class="line"><span class="function">        <span class="title">ADD</span> <span class="params">(BLK_NUM[v], BLK_NUM[u])</span> to CUT_TREE</span></span><br><span class="line"><span class="function">    ENDIF</span></span><br><span class="line"><span class="function">ENDFOR</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">algorithm <span class="title">build</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">DFS_BUILD(<span class="number">0</span>)</span></span><br><span class="line"><span class="function">UNIQUE CUT_TREE</span></span><br></pre></td></tr></table></figure>

<h3 id="Lemma-2-4"><a href="#Lemma-2-4" class="headerlink" title="Lemma 2.4 :"></a>Lemma 2.4 :</h3><p>對邊集 $\text{UNIQUE}$ 的時間複雜度為 $O(\vert E \vert)$<br>proof :<br>首先我們先說明總共 $\text{CUT_TREE}$ 在呼叫完 $\text{DFS_BUILD}$ 後大小為 $O(\vert E \vert)$，對於呼叫一次 $\text{DFS_BUILD}$ 時 $\text{CUT_TREE}$ 大小最多增加 1，因此顯然成立。<br>接著要證這時對於每個點，邊集加入的順序一定是順序的，這一點也顯然，因為兩次 dfs 的順序相同，因此邊集 $\text{UNIQUE}$ 的時間複雜度為 $O(\vert E \vert)$</p>
<h3 id="Corollary-2-3"><a href="#Corollary-2-3" class="headerlink" title="Corollary 2.3 :"></a>Corollary 2.3 :</h3><p>呼叫 $\text{build}$ 的時間複雜度為 $O(\vert V \vert + \vert E \vert) &#x3D; O(\vert V \vert)$</p>
<h3 id="Corollary-2-4"><a href="#Corollary-2-4" class="headerlink" title="Corollary 2.4 :"></a>Corollary 2.4 :</h3><p>呼叫 $\text{decompose}$ + $\text{build}$ 總空間複雜度為$O(\vert V \vert +  \vert E \vert +\frac {\vert E \vert} K) &#x3D; O(\vert V \vert)$</p>
<p>比較有趣一點點的東西就講完了，實作的 code 後面會有。</p>
<h2 id="3-對於樹形固定的樹支援點改值-子樹詢問"><a href="#3-對於樹形固定的樹支援點改值-子樹詢問" class="headerlink" title="3. 對於樹形固定的樹支援點改值 &#x2F; 子樹詢問"></a>3. 對於樹形固定的樹支援點改值 &#x2F; 子樹詢問</h2><p>我們先考慮下列問題<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="在線版的 [樹學奧林匹亞](https://ojdl.ck.tp.edu.tw/problem/7172) by 陳柏凱 becaido orz
">7</span></a></sup><sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="這一題也有複雜度較好的解(例如樹壓平後在線段樹的每一個節點維護一棵自平衡二元樹，總時間複雜度為$O(\vert V \vert \log \vert V \vert + Q\log^2 \vert V \vert)$)， caido 是出離線的然後 cdq 他啦。">8</span></a></sup></p>
<blockquote>
<p>給定一棵定根樹，樹上每個點有一個權值$x_v$，要求在線支援</p>
<ol>
<li>把一個點 $v$ 的 $x_v$ 改掉</li>
<li>詢問對於給定的 $l, r$, $v$ 的子樹有幾個節點 $u$ 滿足 $r \ge x_u \ge l$</li>
</ol>
</blockquote>
<p>這時我們可以考慮對於每一塊維護排序好的 $x_v$ ，便對於每一塊，我們可以尋問這一塊有幾個 $v$ 滿足 $r \ge x_v \ge l$，因此我們可以知道對於每一個詢問，我們可以把它拆成許多塊整塊的詢問與幾次塊內的子樹詢問。</p>
<h3 id="Lemma-3-1"><a href="#Lemma-3-1" class="headerlink" title="Lemma 3.1 :"></a>Lemma 3.1 :</h3><p>塊內的子樹詢問只會出現一次<br>proof :<br>如Lemma 2.3 中提到的，每一塊都是完整的子樹，因此將一棵樹拔掉一些完整的子樹後還是一棵樹，這棵樹必與原本的根在同一塊內，否則就不連通了，因此塊內子樹詢問只會出現一次。</p>
<p>因此令整塊詢問的複雜度為 $O(\text{full_blk})$，塊內詢問的複雜度為 $O(\text{part_blk})$，合併詢問的複雜度為 $O(\text{Qmerge})$，有</p>
<h3 id="Corollary-3-1"><a href="#Corollary-3-1" class="headerlink" title="Corollary 3.1 :"></a>Corollary 3.1 :</h3><p>詢問的複雜度為$O(\text{part_blk} + \frac {\vert V \vert} K (\text{full_blk} + \text{Qmerge}))$</p>
<p>而對於修改就改掉該塊維護的值就好，最糟也可以直接重蓋。<br>因此令修改複雜度為 $O(\text{modify})$, 初始維護各塊的值複雜度為 $O(\text{build_blk})$，我們有</p>
<h3 id="Corollary-3-2"><a href="#Corollary-3-2" class="headerlink" title="Corollary 3.2 :"></a>Corollary 3.2 :</h3><p>總複雜度為$O(\text{build_blk} + Q(\text{modify} + \text{part_blk} + \frac {\vert V \vert} K (\text{full_blk} + \text{Qmerge})))$</p>
<p>對於上面那一題，我們可以在每一塊維護一棵自平衡二元樹或直接維護一個 sort 好的 vector，便可分析複雜度。</p>
<h3 id="Lemma-3-2"><a href="#Lemma-3-2" class="headerlink" title="Lemma 3.2 :"></a>Lemma 3.2 :</h3><p>對於塊內維護自平衡二元樹，總操作複雜度為 $O(\vert V \vert \log \vert V \vert + Q \sqrt{\vert V \vert \log \vert V \vert})$<br>proof :<br>套用上面的複雜度分析，$O(\text{build_blk}) \in O(\vert V \vert\log \vert V \vert)$，$O(\text{modify}) \in O(\log K)$ (自平衡二元樹上 insert &amp; erase)，$O(\text{full_blk}) \in O(\log K)$ (自平衡二元樹上 distance)，$O(\text{part_blk}) \in O(K)$ (樹上 dfs)，$O(\text{Qmerge}) \in O(1)$，可得總複雜度為 $O(\vert V \vert \log \vert V \vert + Q(K + \frac {\vert V \vert} K \log K))$<br>當$K &#x3D; \sqrt{\vert V \vert \log \vert V \vert}$，時可得 $O(\vert V \vert \log \vert V \vert + Q \sqrt{\vert V \vert \log \vert V \vert})$</p>
<h3 id="Lemma-3-3"><a href="#Lemma-3-3" class="headerlink" title="Lemma 3.3 :"></a>Lemma 3.3 :</h3><p>直接用 vector 維護排序好的點值，總操作複雜度為 $O(\vert V \vert \log \vert V \vert + Q \sqrt{\vert V \vert \log \vert V \vert})$<br>套用上面的複雜度分析，$O(\text{build_blk}) \in O(\vert V \vert\log \vert V \vert)$，$O(\text{modify}) \in O(K)$ (vector insert &amp; erase)，$O(\text{full_blk}) \in O(\log K)$ (vector 上二分搜)，$O(\text{part_blk}) \in O(K)$ (樹上 dfs)，$O(\text{Qmerge}) \in O(1)$，可得總複雜度為 $O(\vert V \vert \log \vert V \vert + Q(K + \frac {\vert V \vert} K \log K))$<br>當$K &#x3D; \sqrt{\vert V \vert \log \vert V \vert}$，時可得 $O(\vert V \vert \log \vert V \vert + Q \sqrt{\vert V \vert \log \vert V \vert})$</p>
<p>兩種維護方法的複雜度是相同的，下面是三個操作的實際狀況:</p>
<h3 id="Algorithm-3-1-initialize-block"><a href="#Algorithm-3-1-initialize-block" class="headerlink" title="Algorithm 3.1 : initialize_block"></a>Algorithm 3.1 : initialize_block</h3><blockquote>
<p>輸入 : build 後的結果<br>輸出 : 對於各塊維護所需的值</p>
</blockquote>
<p>pseudocode :</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPDATE_VALUE</span>(v):</span><br><span class="line">INSERT VAL[v] into BLK_VALUE[BLK_NUM[v]]</span><br><span class="line"><span class="function">FOR each child u of v in BLK_TREE <span class="keyword">do</span></span></span><br><span class="line"><span class="function">    <span class="title">UPDATE_VALUE</span><span class="params">(u)</span></span></span><br><span class="line"><span class="function">ENDFOR</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">algorithm <span class="title">initialize_block</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">FOR i =</span> <span class="number">1</span> <span class="function">to BLK_CNT <span class="keyword">do</span> </span></span><br><span class="line"><span class="function">    <span class="title">UPDATE_VALUE</span><span class="params">(vir(i))</span></span></span><br><span class="line"><span class="function">ENDFOR</span></span><br></pre></td></tr></table></figure>

<h3 id="Algorithm-3-2-modify"><a href="#Algorithm-3-2-modify" class="headerlink" title="Algorithm 3.2 : modify"></a>Algorithm 3.2 : modify</h3><blockquote>
<p>輸入 : initialize_block 後的結果，要修改的位置 $v$ 與修改的值 $x$<br>輸出 : 修改後的結果</p>
</blockquote>
<p>pseudocode : </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">algorithm <span class="title">modify</span><span class="params">(v, x)</span>:</span></span><br><span class="line"><span class="function">ERASE VAL[v] from BLK_VALUE[BLK_NUM[v]]</span></span><br><span class="line"><span class="function">VAL[v] :=</span> x</span><br><span class="line">INSERT VAL[v] into BLK_VALUE[BLK_NUM[v]]</span><br></pre></td></tr></table></figure>

<h3 id="Algorithm-3-3-query-subtree"><a href="#Algorithm-3-3-query-subtree" class="headerlink" title="Algorithm 3.3 : query_subtree"></a>Algorithm 3.3 : query_subtree</h3><blockquote>
<p>輸入 : initialize_block 後的結果，詢問的位置 $v$ 與詢問的值 $l, r$<br>輸出 : 對於該詢問的答案</p>
</blockquote>
<p>pseudocode : </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">QEURY_BETWEEN_BLK</span>(b, l, r):</span><br><span class="line">RETURN_VAL := QUERY l, r in BLK_VALUE[b]</span><br><span class="line">FOR each child u of b in CUT_TREE <span class="keyword">do</span></span><br><span class="line">    RETURN_VAL += <span class="built_in">QUERY_BETWEEN_BLK</span>(u, l, r)</span><br><span class="line">ENDFOR</span><br><span class="line">RETURN RETURN_VAL</span><br><span class="line">    </span><br><span class="line">algorithm <span class="built_in">query_subtree</span>(v, l, r):</span><br><span class="line">ANSWER := CHECK l, r with VAL[v]</span><br><span class="line">FOR each u is child of v in BLK_TREE <span class="keyword">do</span></span><br><span class="line">    ANSWER += <span class="built_in">query_subtree</span>(u, l, r)</span><br><span class="line">ENDFOR</span><br><span class="line">IF IS_CUT[v] THEN</span><br><span class="line">    FOR each block b with v as root cut <span class="keyword">do</span></span><br><span class="line">        ANSWER += <span class="built_in">QUERY_BETWEEN_BLK</span>(b, l, r)</span><br><span class="line">    ENDFOR</span><br><span class="line">ENDIF</span><br><span class="line">RETURN ANSWER</span><br></pre></td></tr></table></figure>

<p>附上cpp實作:</p>
<div class='fold collapsed'>
    <div class='fold-title'>
        cpp code
    </div>
    <div class='fold-content'>
        <p>待補，因為資讀好忙，你想要看的話去 part 5 啦。</p>

    </div>
</div>

<h2 id="4-對於樹形固定的樹支援點-邊-改值-路徑詢問"><a href="#4-對於樹形固定的樹支援點-邊-改值-路徑詢問" class="headerlink" title="4. 對於樹形固定的樹支援點(邊)改值 &#x2F; 路徑詢問"></a>4. 對於樹形固定的樹支援點(邊)改值 &#x2F; 路徑詢問</h2><p>我們考慮下列問題<sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Distance Queries on a Tree](https://atcoder.jp/contests/abc294/tasks/abc294_g) from Atcoder Beginner Contest 294">9</span></a></sup><sup id="fnref:10"><a href="#fn:10" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="此題也有複雜度較好的解法(也比較好寫)，例如HLD ($O(N\log^2N)$) 或壓平+線段樹 ($O(N\log N)$)">10</span></a></sup></p>
<blockquote>
<p>給定一顆樹與樹上的邊權，要求在線 支援</p>
<ol>
<li>修改一條邊的邊權</li>
<li>詢問 $u$ 到 $v$ 的距離</li>
</ol>
</blockquote>
<p>我們可以發現在定根之後，我們可以把一段路徑分成幾條從塊內的某個點到 root cut 的路徑 + 幾條塊內兩非 root cut 點的路徑。</p>
<h3 id="Lemma-4-1"><a href="#Lemma-4-1" class="headerlink" title="Lemma 4.1 :"></a>Lemma 4.1 :</h3><p>一條路徑上最多只有一條兩端非 root cut 的路徑<br>proof : 首先對於如果 $u$, $v$ 其中 $u$ 是 $v$ 的祖先，則可以套用 Lemma 3.1 的證明很容易的說明兩端非　root cut 的路徑是 $u$ 的塊內的，因次我們可以把任何 $u$ 到 $v$ 的詢問拆成 $\text{lca}(u,v)$ 到 $u$ 跟 $\text{lca}(u,v)$ 到 $v$，兩端非 root cut 的路徑是 $\text{lca}(u, v)$ 的塊內的。</p>
<p>因此我們只要在每一塊內維護從 root cut 到該節點的訊息就好了，我們便知道整體的複雜度分析就如子樹詢問的一樣。</p>
<h3 id="Lemma-4-2"><a href="#Lemma-4-2" class="headerlink" title="Lemma 4.2 :"></a>Lemma 4.2 :</h3><p>使用上面的作法總複雜度為 $O(\vert V \vert + Q \sqrt {\vert V \vert})$<br>套用上面的複雜度分析，$O(\text{build_blk}) \in O(\vert V \vert)$，$O(\text{modify}) \in O(K)$ (dfs 一次)，$O(\text{full_blk}) \in O(1)$ (陣列查詢一次)，$O(\text{part_blk}) \in O(K)$ (樹上 dfs)，$O(\text{Qmerge}) \in O(1)$，可得總複雜度為 $O(\vert V \vert + Q(K + \frac {\vert V \vert} K))$<br>當$K &#x3D; \sqrt{\vert V \vert}$，時可得 $O(\vert V \vert + Q \sqrt {\vert V \vert})$</p>
<p>下面是操作的實際狀況</p>
<h3 id="Algorithm-4-1-initialize-block-modify"><a href="#Algorithm-4-1-initialize-block-modify" class="headerlink" title="Algorithm 4.1 : initialize block &#x2F; modify"></a>Algorithm 4.1 : initialize block &#x2F; modify</h3><blockquote>
<p>輸入 : build 後的結果 &amp; 要修改的邊與邊權<br>輸出 : 各塊的維護值</p>
</blockquote>
<p>pseudocode :</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPDATE_VALUE</span>(v, distance):</span><br><span class="line">TO_ROOT[v] := distance</span><br><span class="line">FOR each child u of v in BLK_TREE <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">UPDATE_VALUE</span>(u, distance + <span class="built_in">EDGE</span>(v, u))</span><br><span class="line">ENDFOR</span><br><span class="line"></span><br><span class="line">algorithm <span class="built_in">initialize_block</span>():</span><br><span class="line">FOR i = <span class="number">1</span> to BLK_CNT <span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">UPDATE_VALUE</span>(<span class="built_in">vir</span>(i), <span class="number">0</span>)</span><br><span class="line">ENDFOR</span><br><span class="line"></span><br><span class="line">algorithm <span class="built_in">modify</span>(u, v, x):</span><br><span class="line"><span class="built_in">EDGE</span>(u, v) := x</span><br><span class="line">MIN_BLOCK := <span class="built_in">min</span>(BLK_NUM[u], BLK_NUM[v])</span><br><span class="line"><span class="built_in">UPDATE_VALUE</span>(<span class="built_in">vir</span>(MIN_BLK), <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Algorithm-4-2-query"><a href="#Algorithm-4-2-query" class="headerlink" title="Algorithm 4.2 query :"></a>Algorithm 4.2 query :</h3><blockquote>
<p>輸入 : 詢問的路徑的兩端<br>輸出 : 路徑長</p>
</blockquote>
<p>pseudocode : </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">QUERY_IN_BLOCK</span>(u, v):</span><br><span class="line"><span class="function">GET <span class="title">PATH</span><span class="params">(u, v)</span> <span class="comment">// by dfs or any O(K) method</span></span></span><br><span class="line"><span class="function">LENGTH :=</span> <span class="number">0</span></span><br><span class="line"><span class="function">FOR each edge i on <span class="title">PATH</span><span class="params">(u, v)</span> <span class="keyword">do</span>:</span></span><br><span class="line"><span class="function">    ADD WEIGHT of i to LENGTH</span></span><br><span class="line"><span class="function">ENDFOR</span></span><br><span class="line"><span class="function">RETURN LENGTH</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">algorithm query(u, v):</span></span><br><span class="line"><span class="function">GET LCA(u, v) on CUT_TREE // by precomputation or any O(|V|/K) method</span></span><br><span class="line"><span class="function">LCA :=</span> <span class="built_in">LCA</span>(u, v) on CUT_TREE</span><br><span class="line">LENGTH := <span class="number">0</span></span><br><span class="line">WHILE BLK_NUM[u] is <span class="keyword">not</span> LCA <span class="keyword">do</span></span><br><span class="line">    ADD TO_ROOT[u] to LENGTH</span><br><span class="line">    u := ROOT_CUT[blk_num[u]]</span><br><span class="line">ENDWHILE</span><br><span class="line">WHILE BLK_NUM[v] is <span class="keyword">not</span> LCA <span class="keyword">do</span></span><br><span class="line">    ADD TO_ROOT[v] to LENGTH</span><br><span class="line">    v := ROOT_CUT[blk_num[v]]</span><br><span class="line">ENDWHILE</span><br><span class="line">ADD <span class="built_in">QUERY_IN_BLOCK</span>(u, v) to LENGTH</span><br><span class="line">RETURN LENGTH</span><br></pre></td></tr></table></figure>

<p>cpp實作:</p>
<div class='fold collapsed'>
    <div class='fold-title'>
        cpp code
    </div>
    <div class='fold-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;O3,unroll-loops&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC target(<span class="string">&quot;avx2,bmi,bmi2,lzcnt,popcnt&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uwu return 0;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">2e5</span> + <span class="number">5</span>, K = <span class="number">1e2</span>, MAX_BLK = SIZE / K + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; original_tree[SIZE], blk_tree[SIZE + MAX_BLK], cut_tree[MAX_BLK];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> blk_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> cost[SIZE], to_root[SIZE + MAX_BLK];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> blk_num[SIZE], root_cut[MAX_BLK];</span><br><span class="line"></span><br><span class="line">bitset &lt;SIZE&gt; is_cut;</span><br><span class="line"></span><br><span class="line">pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt; edge[SIZE];</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cut_path[MAX_BLK][MAX_BLK];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fs first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dfs_stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs_decompose</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    dfs_stk.<span class="built_in">push_back</span>(nd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:original_tree[nd])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i.fs != rt)&#123;</span><br><span class="line">            ret += <span class="built_in">dfs_decompose</span>(i.fs, nd);</span><br><span class="line">            <span class="keyword">if</span>(ret &gt;= K)&#123;</span><br><span class="line">                is_cut[nd] = <span class="number">1</span>;</span><br><span class="line">                blk_cnt++;</span><br><span class="line">                <span class="keyword">while</span>(dfs_stk.<span class="built_in">back</span>() != nd)&#123;</span><br><span class="line">                    blk_num[dfs_stk.<span class="built_in">back</span>()] = blk_cnt;</span><br><span class="line">                    dfs_stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                root_cut[blk_cnt] = nd;</span><br><span class="line">                ret = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decompose</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">dfs_decompose</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    is_cut[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>((<span class="type">int</span>)dfs_stk.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        blk_cnt++;</span><br><span class="line">        <span class="keyword">while</span>(dfs_stk.<span class="built_in">back</span>() != <span class="number">1</span>)&#123;</span><br><span class="line">            blk_num[dfs_stk.<span class="built_in">back</span>()] = blk_cnt;</span><br><span class="line">            dfs_stk.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        root_cut[blk_cnt] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    blk_cnt++;</span><br><span class="line">    blk_num[<span class="number">1</span>] = blk_cnt;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:original_tree[nd])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i.fs != rt)&#123;</span><br><span class="line">            <span class="built_in">build_tree</span>(i.fs, nd);</span><br><span class="line">            <span class="keyword">if</span>(blk_num[nd] == blk_num[i.fs])&#123;</span><br><span class="line">                blk_tree[nd].<span class="built_in">push_back</span>(i);</span><br><span class="line">                blk_tree[i.fs].<span class="built_in">push_back</span>(&#123;nd, i.sc&#125;);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(is_cut[nd])&#123;</span><br><span class="line">                cut_tree[blk_num[nd]].<span class="built_in">push_back</span>(&#123;blk_num[i.fs], <span class="number">1</span>&#125;);</span><br><span class="line">                cut_tree[blk_num[i.fs]].<span class="built_in">push_back</span>(&#123;blk_num[nd], <span class="number">0</span>&#125;);</span><br><span class="line">                blk_tree[blk_num[i.fs] + N].<span class="built_in">push_back</span>(i);</span><br><span class="line">                blk_tree[i.fs].<span class="built_in">push_back</span>(&#123;blk_num[i.fs] + N, i.sc&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_blk_dis</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> rt, <span class="type">long</span> <span class="type">long</span> dis)</span></span>&#123;</span><br><span class="line">    to_root[nd] = dis;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:blk_tree[nd])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i.fs != rt)&#123;</span><br><span class="line">            <span class="built_in">update_blk_dis</span>(i.fs, nd, cost[i.sc] + dis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_between_blk</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> rt, <span class="type">const</span> <span class="type">int</span> st, pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt; du)</span></span>&#123;</span><br><span class="line">    cut_path[st][nd] = du;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:cut_tree[nd])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i.fs != rt)&#123;</span><br><span class="line">            i.sc ? du.fs++ : du.sc++;</span><br><span class="line">            <span class="built_in">dfs_between_blk</span>(i.fs, nd, st, du);</span><br><span class="line">            i.sc ? du.fs-- : du.sc--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">build_tree</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= blk_cnt; i++)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(cut_tree[i].<span class="built_in">begin</span>(), cut_tree[i].<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">unique</span>(cut_tree[i].<span class="built_in">begin</span>(), cut_tree[i].<span class="built_in">end</span>());</span><br><span class="line">        cut_tree[i].<span class="built_in">erase</span>(it, cut_tree[i].<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">update_blk_dis</span>(i + N, <span class="number">0</span>, <span class="number">0LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= blk_cnt; i++)&#123;</span><br><span class="line">        <span class="built_in">dfs_between_blk</span>(i, <span class="number">0</span>, i, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs_in_blk</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> rt, <span class="type">const</span> <span class="type">int</span> tar, <span class="type">long</span> <span class="type">long</span> &amp;dis)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nd == tar)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:blk_tree[nd])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i.fs != rt)&#123;</span><br><span class="line">            dis += cost[i.sc];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs_in_blk</span>(i.fs, nd, tar, dis))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            dis -= cost[i.sc];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dis = <span class="number">0</span>;</span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; du = cut_path[blk_num[u]][blk_num[v]];</span><br><span class="line">    <span class="keyword">while</span>(du.fs--)&#123;</span><br><span class="line">        dis += to_root[v];</span><br><span class="line">        v = root_cut[blk_num[v]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(du.sc--)&#123;</span><br><span class="line">        dis += to_root[u];</span><br><span class="line">        u = root_cut[blk_num[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs_in_blk</span>(u, <span class="number">0</span>, v, dis);</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u, v, w, i = <span class="number">1</span>; i &lt; N; i++)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        original_tree[u].<span class="built_in">push_back</span>(&#123;v, i&#125;);</span><br><span class="line">        original_tree[v].<span class="built_in">push_back</span>(&#123;u, i&#125;);</span><br><span class="line">        cost[i] = w;</span><br><span class="line">        edge[i] = &#123;u, v&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">decompose</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> Q;</span><br><span class="line">    cin &gt;&gt; Q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a, u, v; Q--;)&#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>)&#123;</span><br><span class="line">            cost[u] = v;</span><br><span class="line">            <span class="built_in">update_blk_dis</span>(<span class="built_in">min</span>(blk_num[edge[u].fs], blk_num[edge[u].sc]) + N, <span class="number">0</span>, <span class="number">0LL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">2</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(u, v) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h2 id="5-樹形改變-加點"><a href="#5-樹形改變-加點" class="headerlink" title="5. 樹形改變 - 加點"></a>5. 樹形改變 - 加點</h2><p>我們考慮GTY <sup id="fnref:11"><a href="#fn:11" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="痾就是[Gty的妹子树](https://www.luogu.com.cn/problem/P2137)
">11</span></a></sup><sup id="fnref:12"><a href="#fn:12" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="這題目前在沒有看到時間優於我的作法的，我的作法也是現在洛谷與hydro OJ 上的最佳解，下方會有相關的複雜度分析">12</span></a></sup></p>
<blockquote>
<p>給定一顆定根樹，樹上每個點 $v$ 都有權重 $w_v$，要求在線支援</p>
<ol>
<li>將點 $v$ 的權重改成 $x$</li>
<li>加上一個新的編號為點 $\vert V \vert + 1$，他的父節點為 $v$ ，權重為 $x$</li>
<li>詢問對於一個節點 $v$ 的子樹內有多少人的權重 &gt; $x$</li>
</ol>
</blockquote>
<p>首先我們先看一些這題目前的現行解法:</p>
<h3 id="1-無複雜度保證的樹分塊"><a href="#1-無複雜度保證的樹分塊" class="headerlink" title="1. 無複雜度保證的樹分塊"></a>1. 無複雜度保證的樹分塊</h3><p>該題原本是使用一種複雜度不受保證的樹分塊做法，在星狀圖上會退化至 $O(Q\vert V \vert)$，現存網路上主要樹分塊做法也是這種的<sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="可以見[ypy的題解](https://www.cnblogs.com/birchtree/p/11323540.html)，有趣的是其中一些實作已經十分接近我的有複雜度保證的做法了，而且我是在想到我的作法後才發現這一篇的">13</span></a></sup></p>
<p>時間:$O(\vert V \vert \log \vert V \vert + Q\vert V \vert)$ ，據說在隨機數據上是 $O(\vert V \vert \log \vert V \vert + Q \sqrt{\vert V \vert} \log \vert V \vert)$<br>空間:$O(\vert V \vert)$</p>
<h3 id="2-時間分塊-持久化線段樹"><a href="#2-時間分塊-持久化線段樹" class="headerlink" title="2. 時間分塊 + 持久化線段樹"></a>2. 時間分塊 + 持久化線段樹</h3><p>將該題轉化為壓平序上的區間小於 $k$ 的值的數目，便可用持久化線段樹解決，每 $B$ 次操作重蓋一次線段樹，每次同時要檢查這 $B$ 次操作對你這次詢問是否有影響，總時間複雜度為 $O(\frac Q B \vert V \vert \log C + QB + \sum \text{lca})$，在$B &#x3D; \sqrt {\frac {\vert V \vert \log C} {\text{lca}}}$ 時可得$O(Q\sqrt {\vert V \vert \log C \ \text{lca}})$，注意到在該題時間分塊的狀況下可以做到$\sum \text{lca} &#x3D; O(Q B)$<br>(其實還可以再更優化，利用建造有序下$O(n + \sqrt{nC})$，查詢$O(\sqrt{n} + \sqrt C)$的分塊法可以處理區間 $&lt; k$ 的數目，而在該題對於加點在時間分塊下維護有序的總時間是$O(\frac {\vert V \vert^2} {B})$，又在時間分塊下可以用總共$O(\frac {\vert V \vert^2} {B})$離散化(將 unordered_map 視為 $O(1)$， 故可以優化到時間$O(Q \sqrt{\vert V \vert})$，空間$O(\vert V \vert)$，值得注意的是該作法常數毫無人性的大，因此在實際運用上應該不適合<sup id="fnref:14"><a href="#fn:14" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="實作細節見[chenxinyang的題解](https://www.luogu.com.cn/article/5t1obhbb)">14</span></a></sup>)<br>時間:$O(\vert V \vert \log \vert V \vert + Q\sqrt {\vert V \vert \log C}) &#x2F; O(\vert V \vert \log \vert V \vert + Q\sqrt {\vert V \vert })$<br>空間:$O(\vert V \vert \log C) &#x2F; O(\vert V \vert)$</p>
<h3 id="3-塊狀鍊表"><a href="#3-塊狀鍊表" class="headerlink" title="3. 塊狀鍊表"></a>3. 塊狀鍊表</h3><p>利用塊狀鍊表 + 動態祖先關係判斷可以在 $O(Q(\frac {\vert V \vert} K \log \vert V \vert + K + \log^2\vert V \vert))$的時間複雜度內完成支援，取$K &#x3D; \sqrt{\vert V \vert \log \vert V \vert}$ 得 $O(Q\sqrt{\vert V \vert \log \vert V \vert} + Q\log^2\vert V \vert)$<br>時間:$O(\vert V \vert \log \vert V \vert + Q\sqrt{\vert V \vert \log \vert V \vert} + Q\log^2\vert V \vert)$ (注意到常數會極大)<br>空間:$O(\vert V \vert)$ (用ETT等方法支援動態祖先關係)</p>
<h3 id="4-深度-BFS-分塊"><a href="#4-深度-BFS-分塊" class="headerlink" title="4. 深度 &#x2F; BFS 分塊"></a>4. 深度 &#x2F; BFS 分塊</h3><p>在深度 &#x2F; BFS 分塊下雖然無法確定總塊數，但可以保證到樹根上的塊數，因此可以做到在每塊支援所有子樹的點，用自平衡二元樹完成此題<sup id="fnref:15"><a href="#fn:15" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="見[Haishu海树的題解](https://www.cnblogs.com/Algebra-hy/p/12177281.html)">15</span></a></sup><br>時間:$O(\vert V \vert \log \vert V \vert + Q\sqrt{\vert V \vert} \log \vert V \vert)$<br>空間:$O(\vert V \vert \sqrt{\vert V \vert})$</p>
<p>那接著看如果是我的樹分塊要怎麼做</p>
<h3 id="樹分塊解"><a href="#樹分塊解" class="headerlink" title="樹分塊解"></a>樹分塊解</h3><p>首先我們先看一個直觀的均攤想法，每個加點操作就直接將其並到原本的塊內，每 $B$<br>次加點操作再將整棵樹重新分塊，因此我們有所有加點操作的總時間複雜度為 $O(\frac Q B \text{build_blk} + Q \ \text{modify})$，而一塊的大小便為最糟$2K + B$，因此可以套Lemma 3.2 的複雜度分析，得到:</p>
<h3 id="Lemma-5-1"><a href="#Lemma-5-1" class="headerlink" title="Lemma 5.1 :"></a>Lemma 5.1 :</h3><p>這種樹分塊法總時間複雜度為 $O(\vert V \vert \log \vert V \vert + Q\sqrt{\vert V \vert \log \vert V \vert})$(在$Q \sim \vert V \vert$)<br>proof :<br>套用上面的複雜度分析，$O(\text{build_blk}) \in O(\vert V \vert\log \vert V \vert)$，$O(\text{modify}) \in O(K + B)$ (vector insert &amp; erase)，$O(\text{full_blk}) \in O(\log (K + B))$ (vector 上二分搜)，$O(\text{part_blk}) \in O((K + B))$ (樹上 dfs)，$O(\text{Qmerge}) \in O(1)$，可得總複雜度為 $O(\vert V \vert \log \vert V \vert + Q(K + B) + \frac {Q\vert V \vert} K \log (K + B) + \frac {Q\vert V \vert} B \log \vert V \vert)$<br>當$B &#x3D; K &#x3D; \sqrt{\vert V \vert \log \vert V \vert}$，時可得 $O(\vert V \vert \log \vert V \vert + Q \sqrt{\vert V \vert \log \vert V \vert})$</p>
<p>因此我們就做完了，好欸，但我自己在猜有可能可以證只要分 $n(V_B) &gt; 2K$ 的，均攤 $O(\frac {\text{build_blk}(N)} {K^2})$，但反正現在這樣常數很好，可以不壓常拿個落谷最佳解。</p>
<p><img src="/../Images/20240825/GTY_Fastest_Code.jpg" alt="GTY_Fastest_Code"></p>
<p>附上醜醜cpp實作</p>
<div class='fold collapsed'>
    <div class='fold-title'>
        cpp code
    </div>
    <div class='fold-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uwu return 0;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/extc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">6e4</span> + <span class="number">5</span>, K = <span class="number">6e3</span>, MAX_BLK = SIZE / K + <span class="number">5</span>, B = <span class="number">1.7e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, Q;</span><br><span class="line"></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; undirected_tree[SIZE], original_tree[SIZE], blk_tree[SIZE + MAX_BLK], cut_tree[MAX_BLK];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> blk_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">tree &lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, null_type, less&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; blk_val[MAX_BLK];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; sub_blk[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> blk_num[SIZE + MAX_BLK], node_val[SIZE], blk_to_cut[MAX_BLK];</span><br><span class="line"></span><br><span class="line">bitset &lt;SIZE&gt; is_cut;</span><br><span class="line"></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; dfs_stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs_decompose</span><span class="params">(<span class="type">int</span> nd)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    dfs_stk.<span class="built_in">push_back</span>(nd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:original_tree[nd])&#123;</span><br><span class="line">        ret += <span class="built_in">dfs_decompose</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(ret &gt;= K)&#123;</span><br><span class="line">            is_cut[nd] = <span class="number">1</span>;</span><br><span class="line">            blk_cnt++;</span><br><span class="line">            sub_blk[nd].<span class="built_in">push_back</span>(blk_cnt);</span><br><span class="line">            <span class="keyword">while</span>(dfs_stk.<span class="built_in">back</span>() != nd)&#123;</span><br><span class="line">                blk_num[dfs_stk.<span class="built_in">back</span>()] = blk_cnt;</span><br><span class="line">                dfs_stk.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            blk_to_cut[blk_cnt] = nd;</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decompose</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">dfs_decompose</span>(<span class="number">1</span>);</span><br><span class="line">    is_cut[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>((<span class="type">int</span>)dfs_stk.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        blk_cnt++;</span><br><span class="line">        sub_blk[<span class="number">1</span>].<span class="built_in">push_back</span>(blk_cnt);</span><br><span class="line">        <span class="keyword">while</span>(dfs_stk.<span class="built_in">back</span>() != <span class="number">1</span>)&#123;</span><br><span class="line">            blk_num[dfs_stk.<span class="built_in">back</span>()] = blk_cnt;</span><br><span class="line">            dfs_stk.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        blk_to_cut[blk_cnt] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    blk_cnt++;</span><br><span class="line">    blk_num[<span class="number">1</span>] = blk_cnt;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree</span><span class="params">(<span class="type">int</span> nd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:original_tree[nd])&#123;</span><br><span class="line">        <span class="built_in">build_tree</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(blk_num[nd] == blk_num[i])&#123;</span><br><span class="line">            blk_tree[nd].<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is_cut[nd])&#123;</span><br><span class="line">            cut_tree[blk_num[nd]].<span class="built_in">push_back</span>(blk_num[i]);</span><br><span class="line">            blk_tree[blk_num[i] + SIZE].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_blk_val</span><span class="params">(<span class="type">int</span> nd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:blk_tree[nd])&#123;</span><br><span class="line">        <span class="built_in">update_blk_val</span>(i);</span><br><span class="line">        blk_val[blk_num[nd]].<span class="built_in">insert</span>(&#123;node_val[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">build_tree</span>(<span class="number">1</span>);</span><br><span class="line">    blk_val[blk_cnt].<span class="built_in">insert</span>(&#123;node_val[<span class="number">1</span>], <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= blk_cnt; i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">unique</span>(cut_tree[i].<span class="built_in">begin</span>(), cut_tree[i].<span class="built_in">end</span>());</span><br><span class="line">        cut_tree[i].<span class="built_in">erase</span>(it, cut_tree[i].<span class="built_in">end</span>());</span><br><span class="line">        blk_num[i + SIZE] = i;</span><br><span class="line">        <span class="built_in">update_blk_val</span>(i + SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear_tree</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= blk_cnt; i++)&#123;</span><br><span class="line">        cut_tree[i].<span class="built_in">clear</span>();</span><br><span class="line">        blk_val[i].<span class="built_in">clear</span>();</span><br><span class="line">        blk_to_cut[i] = <span class="number">0</span>;</span><br><span class="line">        blk_tree[i + SIZE].<span class="built_in">clear</span>();</span><br><span class="line">        blk_num[i + SIZE] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        blk_tree[i].<span class="built_in">clear</span>();</span><br><span class="line">        blk_num[i] = <span class="number">0</span>;</span><br><span class="line">        sub_blk[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    is_cut.<span class="built_in">reset</span>();</span><br><span class="line">    blk_cnt = <span class="number">0</span>;</span><br><span class="line">    dfs_stk.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs_between_blk</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:cut_tree[nd])&#123;</span><br><span class="line">        ret += <span class="built_in">dfs_between_blk</span>(i, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(blk_val[nd].<span class="built_in">upper_bound</span>(&#123;x, SIZE&#125;) != blk_val[nd].<span class="built_in">end</span>())</span><br><span class="line">        ret += blk_val[nd].<span class="built_in">size</span>() -  blk_val[nd].<span class="built_in">order_of_key</span>(*blk_val[nd].<span class="built_in">upper_bound</span>(&#123;x, SIZE&#125;));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:blk_tree[nd])&#123;</span><br><span class="line">        ret += <span class="built_in">query</span>(i, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nd &lt; SIZE)</span><br><span class="line">        ret += node_val[nd] &gt; x;</span><br><span class="line">    <span class="keyword">if</span>(is_cut[nd])&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:sub_blk[nd])&#123;</span><br><span class="line">            ret += <span class="built_in">dfs_between_blk</span>(i, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> bkv blk_val[blk_num[nd]]</span></span><br><span class="line">    <span class="keyword">if</span>(node_val[nd] != <span class="number">-1</span>)&#123;</span><br><span class="line">        bkv.<span class="built_in">erase</span>(bkv.<span class="built_in">lower_bound</span>(&#123;node_val[nd], nd&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    node_val[nd] = x;</span><br><span class="line">    bkv.<span class="built_in">insert</span>(&#123;x, nd&#125;);</span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> bkv</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> nd = ++N;</span><br><span class="line">    original_tree[rt].<span class="built_in">push_back</span>(nd);</span><br><span class="line">    blk_tree[rt].<span class="built_in">push_back</span>(nd);</span><br><span class="line">    blk_num[nd] = blk_num[rt];</span><br><span class="line">    node_val[nd] = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">modify</span>(nd, x);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">direct</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:undirected_tree[nd])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != rt)&#123;</span><br><span class="line">            original_tree[nd].<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">direct</span>(i, nd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt; N; i++)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        undirected_tree[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        undirected_tree[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">direct</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        cin &gt;&gt; node_val[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; Q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> op, u, x, i = <span class="number">0</span>, last = <span class="number">0</span>; i &lt; Q; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i % B == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">clear_tree</span>();</span><br><span class="line">            <span class="built_in">decompose</span>();</span><br><span class="line">            <span class="built_in">build</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; u &gt;&gt; x;</span><br><span class="line">        u ^= last, x ^= last;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">0</span>)&#123;</span><br><span class="line">            last = <span class="built_in">query</span>(u, x);</span><br><span class="line">            cout &lt;&lt; last &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">modify</span>(u, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">add</span>(u, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uwu</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>到這邊大概就堪用了，後面有一些我自己覺得可做的東西，有空再補。</p>
<h2 id="6-利用樹形結合持久化資節-內容待補"><a href="#6-利用樹形結合持久化資節-內容待補" class="headerlink" title="6. 利用樹形結合持久化資節 (內容待補)"></a>6. 利用樹形結合持久化資節 (內容待補)</h2><p>就都只從每個節點的父節點的版本做修改</p>
<h2 id="7-樹形改變-任意定根-merge-split-內容待補"><a href="#7-樹形改變-任意定根-merge-split-內容待補" class="headerlink" title="7. 樹形改變 - 任意定根 &amp; merge &#x2F; split (內容待補)"></a>7. 樹形改變 - 任意定根 &amp; merge &#x2F; split (內容待補)</h2><p>聽 owoovo 說可能可以每塊ETT &#x2F; Menghani-Matani，owoovo 巨砲</p>
<h2 id="8-水母圖上改-內容待補"><a href="#8-水母圖上改-內容待補" class="headerlink" title="8. 水母圖上改 (內容待補)"></a>8. 水母圖上改 (內容待補)</h2><p>把環縮點當根，然後就變序列 + 樹了</p>
<h2 id="9-類似虛樹的操作-內容待補"><a href="#9-類似虛樹的操作-內容待補" class="headerlink" title="9. 類似虛樹的操作 (內容待補)"></a>9. 類似虛樹的操作 (內容待補)</h2><p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc359/tasks/abc359_g">這題</a> 也可以做<br>因為我有每個點到blk_num比他小的點一定會經過blk_num比較小的人的root cut</p>
<h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>第一次寫這種東西，寫得有點爛，但反正都寫了，後面內容待補的如果你通靈出我想講啥然後幫我寫我會很感激地直接放上來，還是再感謝一次 owoovo 跟 Ina，然後我就要回去做正事了，881。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">之所以說 OIer 是因為吳邦一老師就有寫<a target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0166218X12004337">這篇</a>酷東西<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">謝謝施竣耀學長 orzorz<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">沒辦法，Ina 太強了<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">在此 $n(cut)$ 表示根據該分塊法下 cut 的數量<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">下方的pseudocode我改成用0<a href="#fnref:5" rev="footnote">↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">同時在星狀圖上，若沒有對邊集 unique，cut tree 極有可能會有 $O(\vert V \vert)$ 條邊，也會造成時間複雜度的問題<a href="#fnref:6" rev="footnote">↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">在線版的 <a target="_blank" rel="noopener" href="https://ojdl.ck.tp.edu.tw/problem/7172">樹學奧林匹亞</a> by 陳柏凱 becaido orz<a href="#fnref:7" rev="footnote">↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">這一題也有複雜度較好的解(例如樹壓平後在線段樹的每一個節點維護一棵自平衡二元樹，總時間複雜度為$O(\vert V \vert \log \vert V \vert + Q\log^2 \vert V \vert)$)， caido 是出離線的然後 cdq 他啦。<a href="#fnref:8" rev="footnote">↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc294/tasks/abc294_g">Distance Queries on a Tree</a> from Atcoder Beginner Contest 294<a href="#fnref:9" rev="footnote">↩</a></span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">此題也有複雜度較好的解法(也比較好寫)，例如HLD ($O(N\log^2N)$) 或壓平+線段樹 ($O(N\log N)$)<a href="#fnref:10" rev="footnote">↩</a></span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">痾就是<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2137">Gty的妹子树</a><a href="#fnref:11" rev="footnote">↩</a></span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">這題目前在沒有看到時間優於我的作法的，我的作法也是現在洛谷與hydro OJ 上的最佳解，下方會有相關的複雜度分析<a href="#fnref:12" rev="footnote">↩</a></span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">可以見<a target="_blank" rel="noopener" href="https://www.cnblogs.com/birchtree/p/11323540.html">ypy的題解</a>，有趣的是其中一些實作已經十分接近我的有複雜度保證的做法了，而且我是在想到我的作法後才發現這一篇的<a href="#fnref:13" rev="footnote">↩</a></span></li><li id="fn:14"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">實作細節見<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/article/5t1obhbb">chenxinyang的題解</a><a href="#fnref:14" rev="footnote">↩</a></span></li><li id="fn:15"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">見<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Algebra-hy/p/12177281.html">Haishu海树的題解</a><a href="#fnref:15" rev="footnote">↩</a></span></li></ol></div></div><link rel="stylesheet" href="/css/folder.css" type="text/css"><script src="/js/folder.js" type="text/javascript" async></script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2024/08/25/GalleryTest/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

     

    
        <div id="disqus_thread"></div>
        <script>
            /**
            *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
            *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
            
            var disqus_config = function () {
                this.page.url = 'http://thecodingpooh.github.io/2024/08/26/On-a-New-Algorithm-for-Tree-Decomposition/';  // Replace PAGE_URL with your page's canonical URL variable
                this.page.identifier = '2024/08/26/On-a-New-Algorithm-for-Tree-Decomposition/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                this.language = 'en'
            };
            
            (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');
            s.src = 'https://the-coding-poohs-blog.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>   
     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

    
    

  </body>
</html>
